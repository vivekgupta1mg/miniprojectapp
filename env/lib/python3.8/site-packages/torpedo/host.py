from sanic import Sanic
from sanic.log import logger
from sanic.request import Request
from sanic.router import Router
from tortoise.contrib.sanic import register_tortoise

from .common_utils import CONFIG
from .handlers import CustomExceptionHandler, ping
from .listeners import register_redis_cache, set_context_factory
from .log import LOGGING_CONFIG_DEFAULTS
from .middlewares import (handle_apm_request, handle_apm_response,
                          handle_request_id)
from .wrappers import custom_json, request_params


class CustomRouter(Router):
    pass


class Host:
    _name = None
    _host = "0.0.0.0"
    _port = None
    _workers = 1
    _debug = False
    _config = {}
    _blueprint_group = None
    _db_config = None
    _handlers = []
    _swagger_config = None
    _multi_cache = False
    _listeners = []

    @classmethod
    def setup_host(cls):
        # sets up basic service level information for Sanic app to run.
        cls._name = cls._config['NAME']
        cls._host = cls._config['HOST']
        cls._port = cls._config['PORT']
        cls._workers = cls._config.get('WORKERS', 2)  # number of workers to run,
        # keep <= num of cores debug would be true for local, make sure it is
        # false on staging and production. This flag also defines logging
        # in torpedo. If this flag is false then logs are written in files by
        # overriding the default logging settings.
        cls._debug = cls._config.get('DEBUG', True)

    @classmethod
    def setup_app_ctx(cls, _app):
        # a new ctx feature was added in Sanic 21.3.2 which allows setting context vars
        # for a sanic application
        _app.ctx.multi_cache = bool(cls._multi_cache)

    @classmethod
    def get_app(cls):
        # this function will get the sanic app instance based on DEBUG mode. If debug mode
        # is True then logging won't be setup on local machine, i.e. logs will be
        # available only on console and no log writing
        # happens in files. If DEBUG is true then we setup our custom logging.
        # TODO: router = CustomRouter() initialization is done to monkey patch sentry
        #  integration issue
        if cls._config.get('DEBUG'):
            app = Sanic(cls._name, router=CustomRouter())
        else:
            app = Sanic(cls._name, log_config=LOGGING_CONFIG_DEFAULTS, router=CustomRouter())
        return app

    @classmethod
    def register_listeners(cls, _app):
        # registers custom listeners created via torpedo and custom listeners
        # set up by service.
        _app.register_listener(set_context_factory, 'after_server_start')
        _app.register_listener(register_redis_cache, 'after_server_start')
        for _listener, _type in cls._listeners:
            _app.register_listener(_listener, _type)

    @classmethod
    def register_middlewares(cls, _app):
        # registers custom middleware created by torpedo.
        _app.register_middleware(handle_request_id, attach_to='request')
        _app.register_middleware(handle_apm_request, attach_to='request')
        _app.register_middleware(handle_apm_response, attach_to='response')

    @classmethod
    def register_exception_handler(cls, _app):
        # setup custom exception handlers
        _app.error_handler = CustomExceptionHandler()

    @classmethod
    def register_databases(cls, _app):
        # setup database(s)
        if cls._db_config:
            # give preference to the service level db config, if added.
            register_tortoise(_app, config=cls._db_config, generate_schemas=False)
        elif 'POSTGRES_HOST' in _app.config:
            db_config = {
                "connections": {
                    "default": {
                        "engine": "tortoise.backends.asyncpg",
                        "credentials": {
                            "host": _app.config['POSTGRES_HOST'],
                            "port": _app.config['POSTGRES_PORT'],
                            "user": _app.config['POSTGRES_USER'],
                            "password": _app.config['POSTGRES_PASS'],
                            "database": _app.config['POSTGRES_DB']
                        },
                    },
                },
                "apps": {
                    cls._name: {
                        "models": ["app.models"],
                        "default_connection": "default"
                    },
                },
            }
            register_tortoise(_app, config=db_config, generate_schemas=False)
        else:
            logger.info("__setting up service without an active database connection__")

    @classmethod
    def register_app_blueprints(cls, _app):
        """
        :param _app: Sanic app instance
        :return:
        """
        # add a default health check handler
        _app.add_route(ping, '/ping')

        # setup blueprint group coming from the service side.
        _app.blueprint(cls._blueprint_group)

        # this loop does nothing significant but print all the routes present on service
        # via blueprints
        for route in _app.router.routes_all:
            logger.info('/'.join(route))

    @classmethod
    def setup_dynamic_methods(cls):
        setattr(Request, 'request_params', request_params)
        setattr(Request, 'custom_json', custom_json)

    @classmethod
    def run_server(cls, _app):
        _app.run(
            host=cls._host,
            port=cls._port,
            debug=cls._debug,
            workers=cls._workers
        )

    @classmethod
    def run(cls):
        # setup host basic info from config file
        cls._config = CONFIG.config
        cls.setup_host()

        # get instance of the app
        app = cls.get_app()
        # update app config from config.json from service directory
        app.update_config(cls._config)

        # Sanic app instance no longer support assigning attributes, instead use ctx
        cls.setup_app_ctx(app)

        cls.register_databases(app)

        cls.register_listeners(app)
        cls.register_middlewares(app)

        cls.register_exception_handler(app)

        cls.register_app_blueprints(app)

        cls.setup_dynamic_methods()

        cls.run_server(app)
