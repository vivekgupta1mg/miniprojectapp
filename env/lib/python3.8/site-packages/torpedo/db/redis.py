import asyncio
from asyncio import coroutine

import aioredis

allowed_types_for_caching = [str, int, list, tuple, float, dict, bool]


class RedisCache:
    _utf8 = 'utf-8'

    def __init__(self, host, port, minsize=5, maxsize=10, loop=None):
        self._host = host
        self._port = port
        self._minsize = minsize
        self._maxsize = maxsize
        self._lock = asyncio.Semaphore(1)
        self._pool = None
        self._loop = loop

    async def get_pool(self):
        if not self._pool:
            with await self._lock:
                if not self._pool:
                    self._pool = await aioredis.create_redis_pool((self._host, self._port),
                                                                  minsize=self._minsize,
                                                                  maxsize=self._maxsize,
                                                                  loop=self._loop
                                                                  )
        return await self._pool

    async def set_key(self, key, value, namespace=None, expire=0):
        """
        Set a key in a cache.
        :param key: Key name
        :param value: Value
        :param namespace : Namespace to associate the key with
        :param expire: expiration
        :return:
        """
        with (await self.get_pool()) as redis:
            if namespace is not None:
                key = self._get_key(namespace, key)
            await redis.set(key, value, expire=expire)

    async def increment_value(self, key, namespace=None):
        # Set a redis key and increment the value by one
        with (await self.get_pool()) as redis:
            if namespace is not None:
                key = self._get_key(namespace, key)
            await redis.incr(key)

    async def increment_by_value(self, key, value: int, namespace=None):
        with (await self.get_pool()) as redis:
            if namespace is not None:
                key = self._get_key(namespace, key)
            await redis.incrby(key, value)

    @coroutine
    async def set_key_if_not_exists(self, key, value, namespace=None, expire=0):
        """
        Set a redis key and return True if the key does not exists else return False
        :param key: Key name
        :param value: Value
        :param namespace : Namespace to associate the key with
        :param expire: expiration
        :return:
        """
        with (await self.get_pool()) as redis:
            if namespace:
                key = self._get_key(namespace, key)
                return await redis.set(key, value, exist='SET_IF_NOT_EXIST')

    async def get_key(self, key, namespace=None):
        with (await self.get_pool()) as redis:
            if namespace is not None:
                key = self._get_key(namespace, key)
            return await redis.get(key, encoding=self._utf8)

    async def hmget(self, fields, namespace=''):
        with (await self.get_pool()) as redis:
            return await redis.hmget(namespace, *fields, encoding=self._utf8)

    async def hmset(self, field, value, namespace=''):
        with (await self.get_pool()) as redis:
            return await redis.hmset(namespace, field, value)

    async def delete(self, key, namespace=None):
        with (await self.get_pool()) as redis:
            if namespace is not None:
                key = self._get_key(namespace, key)
            await redis.delete(key)

    async def hdel(self, key, namespace):
        with (await self.get_pool()) as redis:
            if namespace is not None:
                await redis.hdel(namespace, key)

    async def hgetall(self, namespace):
        with (await self.get_pool()) as redis:
            if namespace is not None:
                return await redis.hgetall(namespace, encoding=self._utf8)

    async def hincrby(self, field, value: int=1, namespace=''):
        with (await self.get_pool()) as redis:
            return await redis.hincrby(namespace, field, value)

    async def clear_namespace(self, namespace) -> int:
        pattern = namespace + '*'
        return await self._delete_by_pattern(pattern)

    async def _delete_by_pattern(self, pattern: str) -> int:
        if not pattern:
            return 0
        with (await self.get_pool()) as redis:
            _keys = await redis.keys(pattern)
            if _keys:
                await redis.delete(*_keys)
        return len(_keys)

    async def delete_by_prefix(self, prefix, namespace=None):
        prefix_with_namespace = self._get_key(namespace, prefix) if namespace else prefix
        pattern = '{}*'.format(prefix_with_namespace)
        return await self._delete_by_pattern(pattern)

    async def exit(self):
        if self._pool:
            await self._pool.clear()

    @staticmethod
    def _get_key(namespace, key):
        return namespace + ':' + key

    async def keys(self, pattern_str: str):
        """
        Function to get all keys in redis matching to pattern_str
        :param pattern_str: keys pattern
        :return: list of redis keys
        """
        if pattern_str:
            with (await self.get_pool()) as redis:
                return await redis.keys(pattern_str + '*')
        return []
